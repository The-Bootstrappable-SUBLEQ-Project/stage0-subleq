rem Copyright (C) 2022 NyanCatTW1
rem This file is part of stage0-subleq.
rem
rem stage0-subleq is free software: you can redistribute it and/or modify
rem it under the terms of the GNU General Public License as published by
rem the Free Software Foundation, either version 3 of the License, or
rem (at your option) any later version.
rem
rem stage0-subleq is distributed in the hope that it will be useful,
rem but WITHOUT ANY WARRANTY; without even the implied warranty of
rem MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
rem GNU General Public License for more details.
rem
rem You should have received a copy of the GNU General Public License
rem along with stage0-subleq.  If not, see <http://www.gnu.org/licenses/>.

rem Standard program start
addr ZERO 0
var tmp 0
var tmp2 0
addr tmp_addr 0
addr SERIAL_IN 13ED27E8
addr SERIAL_OUT 13ED27F0
addr CPU_CONTROL_START 13EE0000
lblsq ZERO ZERO EP

label EP
var codeLen 0
rem MAIN is the main routine for handling inputs
label MAIN
rem val is intentionally kept negative to make it easier to add to cur
var val 0
var c 0
getchar c tmp
rem Keep a backup of c for INPUT_LABEL
var c2 0
mov c2 c tmp

rem Handle NUL ~ "
decleq c 22 MAIN

rem Handle #
decleq c 1 COMMENT

rem Handle $ and %
decleq c 2 MAIN

rem Handle &
decleq c 1 INPUT_LABEL

rem Handle ' ~ /
decleq c 9 MAIN

rem Handle 0 ~ 9
movneg val c
inc val 1
decleq c a WRITE

rem Handle :
decleq c 1 INPUT_LABEL

rem Handle ;
decleq c 1 COMMENT

rem Handle < ~ >
decleq c 3 MAIN

rem Handle ?
decleq c 1 HANDLE_REL

rem Handle @
decleq c 1 MAIN

rem Handle A ~ F
movneg val c
dec val 9
decleq c 6 WRITE

rem Handle G ~ `
decleq c 1a MAIN

rem Handle a ~ f
movneg val c
dec val 9
decleq c 6 WRITE

rem Handle g ~ }
decleq c 17 MAIN

rem Handle ~ and DEL (0x7f)
lbljmp RESOLVE_REF


rem COMMENT ignores characters until \r or \n is fed
label COMMENT
getchar c tmp
rem putchar c tmp
decleq c 9 COMMENT
rem Handle LF
decleq c 1 MAIN
decleq c 2 COMMENT
rem Handle CR
decleq c 1 MAIN
lbljmp COMMENT


rem HANDLE_REL handles relative labels
label HANDLE_REL

rem Handle sign (+-)
var isNeg 0
zero isNeg
getchar c tmp
rem Handle NUL ~ ,
decleq c 2c REL_INP
inc isNeg 1
rem Handle -
decleq c 1 REL_INP
zero isNeg

label REL_INP
getchar c tmp

rem Handle NUL ~ /
decleq c 2f REL_NEG

rem Handle 0 ~ 9
movneg val c
inc val 1
decleq c a REL_WRITE

rem Handle : ~ @
decleq c 7 REL_NEG

rem Handle A ~ F
movneg val c
dec val 9
decleq c 6 REL_WRITE

rem Handle G ~ `
decleq c 1a REL_NEG

rem Handle a ~ f
movneg val c
dec val 9
decleq c 6 REL_WRITE

rem Handle g ~ DEL
lbljmp REL_INP

label REL_WRITE
mul_16 cur tmp
sub cur val
lbljmp REL_INP

rem Negate cur if the relative jump is negative
label REL_NEG
decleq isNeg 0 REL_FIN
neg cur tmp tmp2

label REL_FIN
add cur codeLen tmp
lbljmp WRITE_QWORD


var labelArrStart 300000

rem INPUT_LABEL handles both labels (:) and references to them (&)
label INPUT_LABEL
rem Transform label name to offset
var labelOffset 0
getchar labelOffset tmp
mul_16 labelOffset tmp
mul_16 labelOffset tmp
getchar tmp2 tmp
add labelOffset tmp2 tmp
mul_8 labelOffset tmp
add labelOffset labelArrStart tmp

decleq c2 26 RECORD_REF

rem Handle label (:)
addr curLabel 0
setaddr curLabel labelOffset tmp
mov curLabel codeLen tmp
lbljmp MAIN

rem Handle reference (&)
label RECORD_REF
var refs 0
addr nextRef 400000
mov nextRef labelOffset tmp
decaddr nextRef -8
mov nextRef codeLen tmp
add nextRef bufStart tmp
decaddr nextRef -8
inc refs 1
lbljmp WRITE_QWORD


rem WRITE adds the hex character to cur, and copies cur to the buffer + increases its address by 8 every 16 characters
label WRITE
var cur 0
mul_16 cur tmp
sub cur val

rem i will turn positive every 16 iterations
var i -f
incleq i 1 MAIN
dec i 10

label WRITE_QWORD
var bufStart 100000
addr bufEnd 100000
rem Copy to the buffer and increase its address
mov bufEnd cur tmp
zero cur
decaddr bufEnd -8
inc codeLen 8
lbljmp MAIN


rem RESOLVE_REF resolves references by setting their value to the label's address
label RESOLVE_REF
decleq refs 0 PRINT
dec refs 1
decaddr nextRef 8

addr refAt 0
setaddr refAt nextRef tmp
decaddr nextRef 8

addr refVal 0
setaddr refVal nextRef tmp

mov refAt refVal tmp
lbljmp RESOLVE_REF


rem PRINT prints the assembled binary file to the serial
label PRINT

addr charToPrint 100000

rem Start from the most significant byte
set i 8
decaddr charToPrint 8

label PRINT_CHAR_START
decaddr charToPrint -1
mov c charToPrint tmp
rem putchar c tmp

rem c %= 256

var mod256IsNeg 0
zero mod256IsNeg
incleq c 1 MOD256_IS_NEG
lbljmp MOD256_IS_POS
label MOD256_IS_NEG
inc mod256IsNeg 1
dec c 1
neg c tmp tmp2
lbljmp MOD256_START
label MOD256_IS_POS
dec c 1

label MOD256_START
var subber 0
set subber 100
rem Finish if c < 256
jl c subber MOD256_CHECKNEG tmp tmp2

rem Multiply subbers by 256 until the next multiplication makes subber > c
var nextSubber 0
set nextSubber 10000
label MULT_SUBBER_START
jl c nextSubber MULT_SUBBER_END tmp tmp2
mul_256 subber tmp
mul_256 nextSubber tmp
rem nextSubber overflowed
decleq nextSubber 0 MULT_SUBBER_END
lbljmp MULT_SUBBER_START
label MULT_SUBBER_END

rem Subtract c by subber until the next subtraction makes c < 0
label SUBTRACT_C
jl c subber MOD256_START tmp tmp2
sub c subber
lbljmp SUBTRACT_C

label MOD256_CHECKNEG
decleq mod256IsNeg 0 MOD256_END
rem No need to invert if c == 0
decleq c 0 MOD256_END
rem c = 256 - c
mov tmp c tmp2
set c 100
sub c tmp

label MOD256_END

putchar c tmp
decleq i 1 PRINT_CHAR_END
lbljmp PRINT_CHAR_START

label PRINT_CHAR_END
rem Go to the next qword
decaddr charToPrint -8
decleq codeLen 8 HALT
lbljmp PRINT

label HALT
rem Stop CPU 0
set_safe CPU_CONTROL_START 2 tmp tmp2

rem Infinite loop
relsq ZERO ZERO 0