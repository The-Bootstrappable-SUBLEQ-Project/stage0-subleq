# hex0
# Copyright (C) 2022 NyanCatTW1
# This file is part of stage0-subleq.

# stage0-subleq is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# stage0-subleq is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with stage0-subleq. If not, see <http://www.gnu.org/licenses/>.

# Standard program start
; addr ZERO 0
; var tmp 0
; var tmp2 0
; addr SERIAL_IN 13ED27E8
; addr SERIAL_OUT 13ED27F0
; addr CPU_CONTROL_START 13EE0000
0000000000000000 0000000000000000 0000000000000018 ; lblsq ZERO ZERO EP

; label EP
# MAIN is the main routine for handling inputs
; label MAIN
# val is intentionally kept negative to make it easier to add to cur
; var val 0
; var c 0

# Start getchar c tmp
# set tmp 1
0000000000001038 0000000000001038 0000000000000030 ; relsq tmp tmp 1
0000000000001038 0000000000001088 0000000000000048 ; relsq tmp CONST_-1 1
0000000000001038 0000000013ed27e8 0000000000000078 ; relsq tmp SERIAL_IN 2
# reljmp -1
0000000000000000 0000000000000000 0000000000000048 ; relsq ZERO ZERO -1
# zero SERIAL_IN
0000000013ed27e8 0000000013ed27e8 0000000000000090 ; relsq SERIAL_IN SERIAL_IN 1
# movneg c tmp
0000000000001050 0000000000001050 00000000000000a8 ; relsq c c 1
0000000000001050 0000000000001038 00000000000000c0 ; relsq c tmp 1
# End getchar

# putchar c tmp

# Handle NUL ~ "
0000000000001050 0000000000001090 0000000000000018 ; lblsq c CONST_22 MAIN

# Handle #
0000000000001050 0000000000001098 00000000000002b8 ; lblsq c CONST_1 COMMENT

# Handle $ ~ /
0000000000001050 00000000000010a0 0000000000000018 ; lblsq c CONST_C MAIN

# Handle 0 ~ 9
# movneg val c
0000000000001048 0000000000001048 0000000000000120 ; relsq val val 1
0000000000001048 0000000000001050 0000000000000138 ; relsq val c 1
0000000000001048 0000000000001088 0000000000000150 ; relsq val CONST_-1 1
0000000000001050 00000000000010a8 00000000000003d8 ; lblsq c CONST_A WRITE

# Handle :
0000000000001050 0000000000001098 0000000000000018 ; lblsq c CONST_1 MAIN

# Handle ;
0000000000001050 0000000000001098 00000000000002b8 ; lblsq c CONST_1 COMMENT

# Handle < ~ @
0000000000001050 00000000000010b0 0000000000000018 ; lblsq c CONST_5 MAIN

# Handle A ~ F
# movneg val c
0000000000001048 0000000000001048 00000000000001c8 ; relsq val val 1
0000000000001048 0000000000001050 00000000000001e0 ; relsq val c 1
0000000000001048 00000000000010b8 00000000000001f8 ; relsq val CONST_9 1
0000000000001050 00000000000010c0 00000000000003d8 ; lblsq c CONST_6 WRITE

# Handle G ~ `
0000000000001050 00000000000010c8 0000000000000018 ; lblsq c CONST_1A MAIN

# Handle a ~ f
# movneg val c
0000000000001048 0000000000001048 0000000000000240 ; relsq val val 1
0000000000001048 0000000000001050 0000000000000258 ; relsq val c 1
0000000000001048 00000000000010b8 0000000000000270 ; relsq val CONST_9 1
0000000000001050 00000000000010c0 00000000000003d8 ; lblsq c CONST_6 WRITE

# Handle g ~ }
0000000000001050 00000000000010d0 0000000000000018 ; lblsq c CONST_17 MAIN

# Handle ~ and DEL (0x7f)
0000000000000000 0000000000000000 00000000000005d0 ; lblsq ZERO ZERO PRINT


# COMMENT ignores characters until \r or \n is fed
; label COMMENT

# Start getchar c tmp
# set tmp 1
0000000000001038 0000000000001038 00000000000002d0 ; relsq tmp tmp 1
0000000000001038 0000000000001088 00000000000002e8 ; relsq tmp CONST_-1 1
0000000000001038 0000000013ed27e8 0000000000000318 ; relsq tmp SERIAL_IN 2
# reljmp -1
0000000000000000 0000000000000000 00000000000002e8 ; relsq ZERO ZERO -1
# zero SERIAL_IN
0000000013ed27e8 0000000013ed27e8 0000000000000330 ; relsq SERIAL_IN SERIAL_IN 1
# movneg c tmp
0000000000001050 0000000000001050 0000000000000348 ; relsq c c 1
0000000000001050 0000000000001038 0000000000000360 ; relsq c tmp 1
# End getchar

# putchar c tmp
0000000000001050 00000000000010b8 00000000000002b8 ; lblsq c CONST_9 COMMENT
# Handle LF
0000000000001050 0000000000001098 0000000000000018 ; lblsq c CONST_1 MAIN
0000000000001050 00000000000010d8 00000000000002b8 ; lblsq c CONST_2 COMMENT
# Handle CR
0000000000001050 0000000000001098 0000000000000018 ; lblsq c CONST_1 MAIN
0000000000000000 0000000000000000 00000000000002b8 ; lblsq ZERO ZERO COMMENT


# WRITE adds the hex character to cur, and copies cur to the buffer + increases its address by 8 every 16 characters
; label WRITE
; var cur 0

# Start mul_16 cur tmp
0000000000001038 0000000000001038 00000000000003f0 ; relsq tmp tmp 1
0000000000001038 0000000000001058 0000000000000408 ; relsq tmp cur 1
0000000000001038 0000000000001058 0000000000000420 ; relsq tmp cur 1
0000000000001038 0000000000001058 0000000000000438 ; relsq tmp cur 1
0000000000001038 0000000000001058 0000000000000450 ; relsq tmp cur 1
0000000000001038 0000000000001058 0000000000000468 ; relsq tmp cur 1
0000000000001058 0000000000001038 0000000000000480 ; relsq cur tmp 1
0000000000001058 0000000000001038 0000000000000498 ; relsq cur tmp 1
0000000000001058 0000000000001038 00000000000004b0 ; relsq cur tmp 1
# End mul_16

0000000000001058 0000000000001048 00000000000004c8 ; relsq cur val 1

# i will turn positive every 16 iterations
; var i -f
0000000000001060 0000000000001088 0000000000000018 ; lblsq i CONST_-1 MAIN

# Copy to the buffer and increase its address
; addr bufEnd 100000
; var codeLen 0

# Start mov bufEnd cur tmp
# movneg tmp cur
0000000000001038 0000000000001038 00000000000004f8 ; relsq tmp tmp 1
0000000000001038 0000000000001058 0000000000000510 ; relsq tmp cur 1
# movneg bufEnd tmp
0000000000100000 0000000000100000 0000000000000528 ; relsq bufEnd bufEnd 1
0000000000100000 0000000000001038 0000000000000540 ; relsq bufEnd tmp 1
# End mov

0000000000001058 0000000000001058 0000000000000558 ; relsq cur cur 1
0000000000000510 00000000000010e0 0000000000000570 ; relsq bufEnd_addrRef_0 CONST_-8 1
0000000000000518 00000000000010e0 0000000000000588 ; relsq bufEnd_addrRef_1 CONST_-8 1
0000000000000528 00000000000010e0 00000000000005a0 ; relsq bufEnd_addrRef_2 CONST_-8 1
0000000000001068 00000000000010e0 00000000000005b8 ; relsq codeLen CONST_-8 1
0000000000001060 00000000000010e8 0000000000000018 ; lblsq i CONST_10 MAIN


# PRINT prints the assembled binary file to the serial
; label PRINT

; addr charToPrint 100000

# Start from the most significant byte
# set i 8
0000000000001060 0000000000001060 00000000000005e8 ; relsq i i 1
0000000000001060 00000000000010e0 0000000000000600 ; relsq i CONST_-8 1
0000000000000650 00000000000010f0 0000000000000618 ; relsq charToPrint_addrRef_0 CONST_8 1

; label PRINT_CHAR_START
0000000000000650 0000000000001088 0000000000000630 ; relsq charToPrint_addrRef_0 CONST_-1 1

# Start mov c charToPrint tmp
# movneg tmp charToPrint
0000000000001038 0000000000001038 0000000000000648 ; relsq tmp tmp 1
0000000000001038 0000000000100000 0000000000000660 ; relsq tmp charToPrint 1
# movneg c tmp
0000000000001050 0000000000001050 0000000000000678 ; relsq c c 1
0000000000001050 0000000000001038 0000000000000690 ; relsq c tmp 1
# End mov

# putchar c tmp

# c %= 256

; var mod256IsNeg 0
0000000000001070 0000000000001070 00000000000006a8 ; relsq mod256IsNeg mod256IsNeg 1
0000000000001050 0000000000001088 00000000000006d8 ; lblsq c CONST_-1 MOD256_IS_NEG
0000000000000000 0000000000000000 00000000000007b0 ; lblsq ZERO ZERO MOD256_IS_POS
; label MOD256_IS_NEG
0000000000001070 0000000000001088 00000000000006f0 ; relsq mod256IsNeg CONST_-1 1
0000000000001050 0000000000001098 0000000000000708 ; relsq c CONST_1 1

# Start neg c tmp tmp2
0000000000001038 0000000000001038 0000000000000720 ; relsq tmp tmp 1
0000000000001038 0000000000001050 0000000000000738 ; relsq tmp c 1
0000000000001040 0000000000001040 0000000000000750 ; relsq tmp2 tmp2 1
0000000000001040 0000000000001038 0000000000000768 ; relsq tmp2 tmp 1
0000000000001050 0000000000001050 0000000000000780 ; relsq c c 1
0000000000001050 0000000000001040 0000000000000798 ; relsq c tmp2 1
# End neg

0000000000000000 0000000000000000 00000000000007c8 ; lblsq ZERO ZERO MOD256_START
; label MOD256_IS_POS
0000000000001050 0000000000001098 00000000000007c8 ; relsq c CONST_1 1

; label MOD256_START
; var subber 0
# set subber 100
0000000000001078 0000000000001078 00000000000007e0 ; relsq subber subber 1
0000000000001078 00000000000010f8 00000000000007f8 ; relsq subber CONST_-100 1
# Finish if c < 256

# Start jl c subber MOD256_CHECKNEG tmp tmp2

# Start mov tmp c tmp2
0000000000001040 0000000000001040 0000000000000810 ; relsq tmp2 tmp2 1
0000000000001040 0000000000001050 0000000000000828 ; relsq tmp2 c 1
0000000000001038 0000000000001038 0000000000000840 ; relsq tmp tmp 1
0000000000001038 0000000000001040 0000000000000858 ; relsq tmp tmp2 1
# End mov

# inc tmp 1
0000000000001038 0000000000001088 0000000000000870 ; relsq tmp CONST_-1 1
0000000000001038 0000000000001078 0000000000000d98 ; lblsq tmp subber MOD256_CHECKNEG
# End jl


# Multiply subbers by 256 until the next multiplication makes subber > c
; var nextSubber 0
# set nextSubber 10000
0000000000001080 0000000000001080 00000000000008a0 ; relsq nextSubber nextSubber 1
0000000000001080 0000000000001100 00000000000008b8 ; relsq nextSubber CONST_-10000 1
; label MULT_SUBBER_START

# Start jl c nextSubber MULT_SUBBER_END tmp tmp2

# Start mov tmp c tmp2
0000000000001040 0000000000001040 00000000000008d0 ; relsq tmp2 tmp2 1
0000000000001040 0000000000001050 00000000000008e8 ; relsq tmp2 c 1
0000000000001038 0000000000001038 0000000000000900 ; relsq tmp tmp 1
0000000000001038 0000000000001040 0000000000000918 ; relsq tmp tmp2 1
# End mov

# inc tmp 1
0000000000001038 0000000000001088 0000000000000930 ; relsq tmp CONST_-1 1
0000000000001038 0000000000001080 0000000000000cd8 ; lblsq tmp nextSubber MULT_SUBBER_END
# End jl


# Start mul_256 subber tmp
0000000000001038 0000000000001038 0000000000000960 ; relsq tmp tmp 1
0000000000001038 0000000000001078 0000000000000978 ; relsq tmp subber 1
0000000000001038 0000000000001078 0000000000000990 ; relsq tmp subber 1
0000000000001038 0000000000001078 00000000000009a8 ; relsq tmp subber 1
0000000000001038 0000000000001078 00000000000009c0 ; relsq tmp subber 1
0000000000001038 0000000000001078 00000000000009d8 ; relsq tmp subber 1
0000000000001078 0000000000001038 00000000000009f0 ; relsq subber tmp 1
0000000000001078 0000000000001038 0000000000000a08 ; relsq subber tmp 1
0000000000001078 0000000000001038 0000000000000a20 ; relsq subber tmp 1
0000000000001038 0000000000001038 0000000000000a38 ; relsq tmp tmp 1
0000000000001038 0000000000001078 0000000000000a50 ; relsq tmp subber 1
0000000000001038 0000000000001078 0000000000000a68 ; relsq tmp subber 1
0000000000001038 0000000000001078 0000000000000a80 ; relsq tmp subber 1
0000000000001038 0000000000001078 0000000000000a98 ; relsq tmp subber 1
0000000000001038 0000000000001078 0000000000000ab0 ; relsq tmp subber 1
0000000000001078 0000000000001038 0000000000000ac8 ; relsq subber tmp 1
0000000000001078 0000000000001038 0000000000000ae0 ; relsq subber tmp 1
0000000000001078 0000000000001038 0000000000000af8 ; relsq subber tmp 1
# End mul_256


# Start mul_256 nextSubber tmp
0000000000001038 0000000000001038 0000000000000b10 ; relsq tmp tmp 1
0000000000001038 0000000000001080 0000000000000b28 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000b40 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000b58 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000b70 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000b88 ; relsq tmp nextSubber 1
0000000000001080 0000000000001038 0000000000000ba0 ; relsq nextSubber tmp 1
0000000000001080 0000000000001038 0000000000000bb8 ; relsq nextSubber tmp 1
0000000000001080 0000000000001038 0000000000000bd0 ; relsq nextSubber tmp 1
0000000000001038 0000000000001038 0000000000000be8 ; relsq tmp tmp 1
0000000000001038 0000000000001080 0000000000000c00 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000c18 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000c30 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000c48 ; relsq tmp nextSubber 1
0000000000001038 0000000000001080 0000000000000c60 ; relsq tmp nextSubber 1
0000000000001080 0000000000001038 0000000000000c78 ; relsq nextSubber tmp 1
0000000000001080 0000000000001038 0000000000000c90 ; relsq nextSubber tmp 1
0000000000001080 0000000000001038 0000000000000ca8 ; relsq nextSubber tmp 1
# End mul_256

# nextSubber overflowed
0000000000001080 0000000000001108 0000000000000cd8 ; lblsq nextSubber CONST_0 MULT_SUBBER_END
0000000000000000 0000000000000000 00000000000008b8 ; lblsq ZERO ZERO MULT_SUBBER_START
; label MULT_SUBBER_END

# Subtract c by subber until the next subtraction makes c < 0
; label SUBTRACT_C

# Start jl c subber MOD256_START tmp tmp2

# Start mov tmp c tmp2
0000000000001040 0000000000001040 0000000000000cf0 ; relsq tmp2 tmp2 1
0000000000001040 0000000000001050 0000000000000d08 ; relsq tmp2 c 1
0000000000001038 0000000000001038 0000000000000d20 ; relsq tmp tmp 1
0000000000001038 0000000000001040 0000000000000d38 ; relsq tmp tmp2 1
# End mov

# inc tmp 1
0000000000001038 0000000000001088 0000000000000d50 ; relsq tmp CONST_-1 1
0000000000001038 0000000000001078 00000000000007c8 ; lblsq tmp subber MOD256_START
# End jl

0000000000001050 0000000000001078 0000000000000d80 ; relsq c subber 1
0000000000000000 0000000000000000 0000000000000cd8 ; lblsq ZERO ZERO SUBTRACT_C

; label MOD256_CHECKNEG
0000000000001070 0000000000001108 0000000000000e70 ; lblsq mod256IsNeg CONST_0 MOD256_END
# No need to invert if c == 0
0000000000001050 0000000000001108 0000000000000e70 ; lblsq c CONST_0 MOD256_END
# c = 256 - c

# Start mov tmp c tmp2
# movneg tmp2 c
0000000000001040 0000000000001040 0000000000000de0 ; relsq tmp2 tmp2 1
0000000000001040 0000000000001050 0000000000000df8 ; relsq tmp2 c 1
# movneg tmp tmp2
0000000000001038 0000000000001038 0000000000000e10 ; relsq tmp tmp 1
0000000000001038 0000000000001040 0000000000000e28 ; relsq tmp tmp2 1
# End mov

# set c 100
0000000000001050 0000000000001050 0000000000000e40 ; relsq c c 1
0000000000001050 00000000000010f8 0000000000000e58 ; relsq c CONST_-100 1
0000000000001050 0000000000001038 0000000000000e70 ; relsq c tmp 1

; label MOD256_END


# Start putchar c tmp
0000000013ed27f0 0000000000000000 0000000000000ea0 ; relsq SERIAL_OUT ZERO 2
# reljmp -1
0000000000000000 0000000000000000 0000000000000e70 ; relsq ZERO ZERO -1
# movneg tmp c
0000000000001038 0000000000001038 0000000000000eb8 ; relsq tmp tmp 1
0000000000001038 0000000000001050 0000000000000ed0 ; relsq tmp c 1
# dec tmp 1
0000000000001038 0000000000001098 0000000000000ee8 ; relsq tmp CONST_1 1
# movneg SERIAL_OUT tmp
0000000013ed27f0 0000000013ed27f0 0000000000000f00 ; relsq SERIAL_OUT SERIAL_OUT 1
0000000013ed27f0 0000000000001038 0000000000000f18 ; relsq SERIAL_OUT tmp 1
# End putchar

0000000000001060 0000000000001098 0000000000000f48 ; lblsq i CONST_1 PRINT_CHAR_END
0000000000000000 0000000000000000 0000000000000618 ; lblsq ZERO ZERO PRINT_CHAR_START

; label PRINT_CHAR_END
# Go to the next qword
0000000000000650 00000000000010e0 0000000000000f60 ; relsq charToPrint_addrRef_0 CONST_-8 1
0000000000001068 00000000000010f0 0000000000000f90 ; lblsq codeLen CONST_8 HALT
0000000000000000 0000000000000000 00000000000005d0 ; lblsq ZERO ZERO PRINT

; label HALT
# Stop CPU 0

# Start set_safe CPU_CONTROL_START 2 tmp tmp2

# Start mov tmp CPU_CONTROL_START tmp2
0000000000001040 0000000000001040 0000000000000fa8 ; relsq tmp2 tmp2 1
0000000000001040 0000000013ee0000 0000000000000fc0 ; relsq tmp2 CPU_CONTROL_START 1
0000000000001038 0000000000001038 0000000000000fd8 ; relsq tmp tmp 1
0000000000001038 0000000000001040 0000000000000ff0 ; relsq tmp tmp2 1
# End mov

# dec tmp 2
0000000000001038 00000000000010d8 0000000000001008 ; relsq tmp CONST_2 1
# sub CPU_CONTROL_START tmp
0000000013ee0000 0000000000001038 0000000000001020 ; relsq CPU_CONTROL_START tmp 1
# End set_safe


# Infinite loop
0000000000000000 0000000000000000 0000000000001020 ; relsq ZERO ZERO 0

; var CONST_-1 -1
; var CONST_22 22
; var CONST_1 1
; var CONST_C c
; var CONST_A a
; var CONST_5 5
; var CONST_9 9
; var CONST_6 6
; var CONST_1A 1a
; var CONST_17 17
; var CONST_2 2
; var CONST_-8 -8
; var CONST_10 10
; var CONST_8 8
; var CONST_-100 -100
; var CONST_-10000 -10000
; var CONST_0 0

0000000000000000 ; raw 0000000000000000 # tmp
0000000000000000 ; raw 0000000000000000 # tmp2
0000000000000000 ; raw 0000000000000000 # val
0000000000000000 ; raw 0000000000000000 # c
0000000000000000 ; raw 0000000000000000 # cur
fffffffffffffff1 ; raw fffffffffffffff1 # i
0000000000000000 ; raw 0000000000000000 # codeLen
0000000000000000 ; raw 0000000000000000 # mod256IsNeg
0000000000000000 ; raw 0000000000000000 # subber
0000000000000000 ; raw 0000000000000000 # nextSubber
ffffffffffffffff ; raw ffffffffffffffff # CONST_-1
0000000000000022 ; raw 0000000000000022 # CONST_22
0000000000000001 ; raw 0000000000000001 # CONST_1
000000000000000c ; raw 000000000000000c # CONST_C
000000000000000a ; raw 000000000000000a # CONST_A
0000000000000005 ; raw 0000000000000005 # CONST_5
0000000000000009 ; raw 0000000000000009 # CONST_9
0000000000000006 ; raw 0000000000000006 # CONST_6
000000000000001a ; raw 000000000000001a # CONST_1A
0000000000000017 ; raw 0000000000000017 # CONST_17
0000000000000002 ; raw 0000000000000002 # CONST_2
fffffffffffffff8 ; raw fffffffffffffff8 # CONST_-8
0000000000000010 ; raw 0000000000000010 # CONST_10
0000000000000008 ; raw 0000000000000008 # CONST_8
ffffffffffffff00 ; raw ffffffffffffff00 # CONST_-100
ffffffffffff0000 ; raw ffffffffffff0000 # CONST_-10000
0000000000000000 ; raw 0000000000000000 # CONST_0
~
