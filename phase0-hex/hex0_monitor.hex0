# hex0
# Step 0: Processed 356 lines
# Step 1: Found 33 symbols
# Step 2: Now with 33 symbols and 154 references
# Step 3: Now with 363 lines and 165 references
# Step 4: Current size is 1928 bytes
# Copyright (C) 2022 NyanCatTW1
# This file is part of stage0-subleq.

# stage0-subleq is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# stage0-subleq is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with stage0-subleq.  If not, see <http://www.gnu.org/licenses/>.

# Standard program start
; addr ZERO 0
; var tmp 0
; addr SERIAL_IN 13ED27E8
; addr SERIAL_OUT 13ED27F0
0000000000000000 0000000000000000 0000000000000018 ; lblsq ZERO ZERO EP

; label EP
# MAIN is the main routine for handling inputs
; label MAIN
# val is intentionally kept negative to make it easier to add to cur
; var val 0
; var c 0
# MSQ_START 0 getchar c tmp
# MSQ_START 1 set tmp 1
# MSQ_START 2 zero tmp
0000000000000788 0000000000000788 0000000000000030 ; relsq tmp tmp 1
# MSQ_END 2 zero
# MSQ_START 2 inc tmp 1
0000000000000788 00000000000007b8 0000000000000048 ; relsq tmp CONST_-1 1
# MSQ_END 2 inc
# MSQ_END 1 set
0000000000000788 0000000013ed27e8 0000000000000078 ; relsq tmp SERIAL_IN 2
# MSQ_START 1 reljmp -1
0000000000000000 0000000000000000 0000000000000048 ; relsq ZERO ZERO -1
# MSQ_END 1 reljmp
# MSQ_START 1 zero SERIAL_IN
# MSQ_START 2 sub SERIAL_IN SERIAL_IN
0000000013ed27e8 0000000013ed27e8 0000000000000090 ; relsq SERIAL_IN SERIAL_IN 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 movneg c tmp
# MSQ_START 2 zero c
0000000000000798 0000000000000798 00000000000000a8 ; relsq c c 1
# MSQ_END 2 zero
# MSQ_START 2 sub c tmp
0000000000000798 0000000000000788 00000000000000c0 ; relsq c tmp 1
# MSQ_END 2 sub
# MSQ_END 1 movneg
# MSQ_END 0 getchar
# putchar c tmp

# Handle NUL ~ "
# MSQ_START 0 decleq c 22 MAIN
0000000000000798 00000000000007c0 0000000000000018 ; lblsq c CONST_22 MAIN
# MSQ_END 0 decleq

# Handle #
# MSQ_START 0 decleq c 1 COMMENT
0000000000000798 00000000000007c8 00000000000002b8 ; lblsq c CONST_1 COMMENT
# MSQ_END 0 decleq

# Handle $ ~ /
# MSQ_START 0 decleq c c MAIN
0000000000000798 00000000000007d0 0000000000000018 ; lblsq c CONST_C MAIN
# MSQ_END 0 decleq

# Handle 0 ~ 9
# MSQ_START 0 movneg val c
# MSQ_START 1 zero val
# MSQ_START 2 sub val val
0000000000000790 0000000000000790 0000000000000120 ; relsq val val 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 sub val c
0000000000000790 0000000000000798 0000000000000138 ; relsq val c 1
# MSQ_END 1 sub
# MSQ_END 0 movneg
# MSQ_START 0 inc val 1
# MSQ_START 1 dec val -1
0000000000000790 00000000000007b8 0000000000000150 ; relsq val CONST_-1 1
# MSQ_END 1 dec
# MSQ_END 0 inc
# MSQ_START 0 decleq c a WRITE
0000000000000798 00000000000007d8 00000000000003d8 ; lblsq c CONST_A WRITE
# MSQ_END 0 decleq

# Handle :
# MSQ_START 0 decleq c 1 MAIN
0000000000000798 00000000000007c8 0000000000000018 ; lblsq c CONST_1 MAIN
# MSQ_END 0 decleq

# Handle ;
# MSQ_START 0 decleq c 1 COMMENT
0000000000000798 00000000000007c8 00000000000002b8 ; lblsq c CONST_1 COMMENT
# MSQ_END 0 decleq

# Handle < ~ @
# MSQ_START 0 decleq c 5 MAIN
0000000000000798 00000000000007e0 0000000000000018 ; lblsq c CONST_5 MAIN
# MSQ_END 0 decleq

# Handle A ~ F
# MSQ_START 0 movneg val c
# MSQ_START 1 zero val
# MSQ_START 2 sub val val
0000000000000790 0000000000000790 00000000000001c8 ; relsq val val 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 sub val c
0000000000000790 0000000000000798 00000000000001e0 ; relsq val c 1
# MSQ_END 1 sub
# MSQ_END 0 movneg
# MSQ_START 0 dec val 9
0000000000000790 00000000000007e8 00000000000001f8 ; relsq val CONST_9 1
# MSQ_END 0 dec
# MSQ_START 0 decleq c 6 WRITE
0000000000000798 00000000000007f0 00000000000003d8 ; lblsq c CONST_6 WRITE
# MSQ_END 0 decleq

# Handle G ~ `
# MSQ_START 0 decleq c 1a MAIN
0000000000000798 00000000000007f8 0000000000000018 ; lblsq c CONST_1A MAIN
# MSQ_END 0 decleq

# Handle a ~ f
# MSQ_START 0 movneg val c
# MSQ_START 1 zero val
# MSQ_START 2 sub val val
0000000000000790 0000000000000790 0000000000000240 ; relsq val val 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 sub val c
0000000000000790 0000000000000798 0000000000000258 ; relsq val c 1
# MSQ_END 1 sub
# MSQ_END 0 movneg
# MSQ_START 0 dec val 9
0000000000000790 00000000000007e8 0000000000000270 ; relsq val CONST_9 1
# MSQ_END 0 dec
# MSQ_START 0 decleq c 6 WRITE
0000000000000798 00000000000007f0 00000000000003d8 ; lblsq c CONST_6 WRITE
# MSQ_END 0 decleq

# Handle g ~ }
# MSQ_START 0 decleq c 17 MAIN
0000000000000798 0000000000000800 0000000000000018 ; lblsq c CONST_17 MAIN
# MSQ_END 0 decleq

# Handle ~ and DEL (0x7f)
# MSQ_START 0 lbljmp COPY
0000000000000000 0000000000000000 00000000000005e8 ; lblsq ZERO ZERO COPY
# MSQ_END 0 lbljmp


# COMMENT ignores characters until \r or \n is fed
; label COMMENT
# MSQ_START 0 getchar c tmp
# MSQ_START 1 set tmp 1
# MSQ_START 2 zero tmp
0000000000000788 0000000000000788 00000000000002d0 ; relsq tmp tmp 1
# MSQ_END 2 zero
# MSQ_START 2 inc tmp 1
0000000000000788 00000000000007b8 00000000000002e8 ; relsq tmp CONST_-1 1
# MSQ_END 2 inc
# MSQ_END 1 set
0000000000000788 0000000013ed27e8 0000000000000318 ; relsq tmp SERIAL_IN 2
# MSQ_START 1 reljmp -1
0000000000000000 0000000000000000 00000000000002e8 ; relsq ZERO ZERO -1
# MSQ_END 1 reljmp
# MSQ_START 1 zero SERIAL_IN
# MSQ_START 2 sub SERIAL_IN SERIAL_IN
0000000013ed27e8 0000000013ed27e8 0000000000000330 ; relsq SERIAL_IN SERIAL_IN 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 movneg c tmp
# MSQ_START 2 zero c
0000000000000798 0000000000000798 0000000000000348 ; relsq c c 1
# MSQ_END 2 zero
# MSQ_START 2 sub c tmp
0000000000000798 0000000000000788 0000000000000360 ; relsq c tmp 1
# MSQ_END 2 sub
# MSQ_END 1 movneg
# MSQ_END 0 getchar
# putchar c tmp
# MSQ_START 0 decleq c 9 COMMENT
0000000000000798 00000000000007e8 00000000000002b8 ; lblsq c CONST_9 COMMENT
# MSQ_END 0 decleq
# Handle LF
# MSQ_START 0 decleq c 1 MAIN
0000000000000798 00000000000007c8 0000000000000018 ; lblsq c CONST_1 MAIN
# MSQ_END 0 decleq
# MSQ_START 0 decleq c 2 COMMENT
0000000000000798 0000000000000808 00000000000002b8 ; lblsq c CONST_2 COMMENT
# MSQ_END 0 decleq
# Handle CR
# MSQ_START 0 decleq c 1 MAIN
0000000000000798 00000000000007c8 0000000000000018 ; lblsq c CONST_1 MAIN
# MSQ_END 0 decleq
# MSQ_START 0 lbljmp COMMENT
0000000000000000 0000000000000000 00000000000002b8 ; lblsq ZERO ZERO COMMENT
# MSQ_END 0 lbljmp


# WRITE adds the hex character to cur, and copies cur to the buffer + increases its address by 8 every 16 characters
; label WRITE
; var cur 0
# MSQ_START 0 mul_16 cur tmp
# MSQ_START 1 zero tmp
# MSQ_START 2 sub tmp tmp
0000000000000788 0000000000000788 00000000000003f0 ; relsq tmp tmp 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 sub tmp cur
0000000000000788 00000000000007a0 0000000000000408 ; relsq tmp cur 1
# MSQ_END 1 sub
# MSQ_START 1 sub tmp cur
0000000000000788 00000000000007a0 0000000000000420 ; relsq tmp cur 1
# MSQ_END 1 sub
# MSQ_START 1 sub tmp cur
0000000000000788 00000000000007a0 0000000000000438 ; relsq tmp cur 1
# MSQ_END 1 sub
# MSQ_START 1 sub tmp cur
0000000000000788 00000000000007a0 0000000000000450 ; relsq tmp cur 1
# MSQ_END 1 sub
# MSQ_START 1 sub tmp cur
0000000000000788 00000000000007a0 0000000000000468 ; relsq tmp cur 1
# MSQ_END 1 sub
# MSQ_START 1 sub cur tmp
00000000000007a0 0000000000000788 0000000000000480 ; relsq cur tmp 1
# MSQ_END 1 sub
# MSQ_START 1 sub cur tmp
00000000000007a0 0000000000000788 0000000000000498 ; relsq cur tmp 1
# MSQ_END 1 sub
# MSQ_START 1 sub cur tmp
00000000000007a0 0000000000000788 00000000000004b0 ; relsq cur tmp 1
# MSQ_END 1 sub
# MSQ_END 0 mul_16
# MSQ_START 0 sub cur val
00000000000007a0 0000000000000790 00000000000004c8 ; relsq cur val 1
# MSQ_END 0 sub

# i will turn positive every 16 iterations
; var i -f
# MSQ_START 0 incleq i 1 MAIN
# MSQ_START 1 decleq i -1 MAIN
00000000000007a8 00000000000007b8 0000000000000018 ; lblsq i CONST_-1 MAIN
# MSQ_END 1 decleq
# MSQ_END 0 incleq

# Copy to the buffer and increase its address
; addr dstEnd 0
; addr bufEnd 100000
# The buffer is also intentionally kept negative to ease copying
# MSQ_START 0 movneg bufEnd cur
# MSQ_START 1 zero bufEnd
# MSQ_START 2 sub bufEnd bufEnd
0000000000100000 0000000000100000 00000000000004f8 ; relsq bufEnd bufEnd 1
# MSQ_END 2 sub
# MSQ_END 1 zero
# MSQ_START 1 sub bufEnd cur
0000000000100000 00000000000007a0 0000000000000510 ; relsq bufEnd cur 1
# MSQ_END 1 sub
# MSQ_END 0 movneg
# MSQ_START 0 zero cur
# MSQ_START 1 sub cur cur
00000000000007a0 00000000000007a0 0000000000000528 ; relsq cur cur 1
# MSQ_END 1 sub
# MSQ_END 0 zero
# MSQ_START 0 decaddr dstEnd -8
00000000000006d8 0000000000000810 0000000000000540 ; relsq dstEnd_addrRef_0 CONST_-8 1
00000000000006e0 0000000000000810 0000000000000558 ; relsq dstEnd_addrRef_1 CONST_-8 1
00000000000006f0 0000000000000810 0000000000000570 ; relsq dstEnd_addrRef_2 CONST_-8 1
# MSQ_END 0 decaddr
# MSQ_START 0 decaddr bufEnd -8
00000000000004e0 0000000000000810 0000000000000588 ; relsq bufEnd_addrRef_0 CONST_-8 1
00000000000004e8 0000000000000810 00000000000005a0 ; relsq bufEnd_addrRef_1 CONST_-8 1
00000000000004f8 0000000000000810 00000000000005b8 ; relsq bufEnd_addrRef_2 CONST_-8 1
00000000000006f8 0000000000000810 00000000000005d0 ; relsq bufEnd_addrRef_3 CONST_-8 1
# MSQ_END 0 decaddr
# MSQ_START 0 decleq i 10 MAIN
00000000000007a8 0000000000000818 0000000000000018 ; lblsq i CONST_10 MAIN
# MSQ_END 0 decleq


# COPY copies the loader to a lower memory (To avoid overwriting) and jumps to the loader
; label COPY
; addr loaderDst 200000
; addr loaderStart 200000
; var loaderLen b0
# MSQ_START 0 mov loaderDst LOADER tmp
# MSQ_START 1 movneg tmp LOADER
# MSQ_START 2 zero tmp
0000000000000788 0000000000000788 0000000000000600 ; relsq tmp tmp 1
# MSQ_END 2 zero
# MSQ_START 2 sub tmp LOADER
0000000000000788 00000000000006d8 0000000000000618 ; relsq tmp LOADER 1
# MSQ_END 2 sub
# MSQ_END 1 movneg
# MSQ_START 1 movneg loaderDst tmp
# MSQ_START 2 zero loaderDst
0000000000200000 0000000000200000 0000000000000630 ; relsq loaderDst loaderDst 1
# MSQ_END 2 zero
# MSQ_START 2 sub loaderDst tmp
0000000000200000 0000000000000788 0000000000000648 ; relsq loaderDst tmp 1
# MSQ_END 2 sub
# MSQ_END 1 movneg
# MSQ_END 0 mov
# MSQ_START 0 decaddr LOADER -8
0000000000000608 0000000000000810 0000000000000660 ; relsq LOADER_addrRef_0 CONST_-8 1
# MSQ_END 0 decaddr
# MSQ_START 0 decaddr loaderDst -8
0000000000000618 0000000000000810 0000000000000678 ; relsq loaderDst_addrRef_0 CONST_-8 1
0000000000000620 0000000000000810 0000000000000690 ; relsq loaderDst_addrRef_1 CONST_-8 1
0000000000000630 0000000000000810 00000000000006a8 ; relsq loaderDst_addrRef_2 CONST_-8 1
# MSQ_END 0 decaddr
# Jump to loaderDst once loaderLen is <= 0
# MSQ_START 0 decleq loaderLen 8 loaderStart
00000000000007b0 0000000000000820 0000000000200000 ; lblsq loaderLen CONST_8 loaderStart
# MSQ_END 0 decleq
# MSQ_START 0 lbljmp COPY
0000000000000000 0000000000000000 00000000000005e8 ; lblsq ZERO ZERO COPY
# MSQ_END 0 lbljmp


# LOADER copies the buffer to the highest memory (0~...) and jumps to 0
# No external variables are used within LOADER, as those would be overridden by the new program
# The addresses are also hardcoded based on loaderStart
; label LOADER
0000000000000000 0000000000000000 0000000000200018 ; abssq dstEnd dstEnd 200018
0000000000000000 0000000000100000 0000000000200030 ; abssq dstEnd bufEnd 200030
# Decrease bufEnd by 8
0000000000200020 00000000002000a8 0000000000200048 ; raw 0000000000200020 00000000002000a8 0000000000200048
# Decrease dstEnd by 8, and jump to 0 if dstEnd <= 0
0000000000200000 00000000002000a8 0000000000200060 ; raw 0000000000200000 00000000002000a8 0000000000200060
0000000000200008 00000000002000a8 0000000000200078 ; raw 0000000000200008 00000000002000a8 0000000000200078
0000000000200018 00000000002000a8 0000000000000000 ; raw 0000000000200018 00000000002000a8 0000000000000000
# Rerun the loop
0000000000000000 0000000000000000 0000000000200000 ; raw 0000000000000000 0000000000000000 0000000000200000
# CONST_8
0000000000000008 ; raw 0000000000000008

; var CONST_-1 -1
; var CONST_22 22
; var CONST_1 1
; var CONST_C c
; var CONST_A a
; var CONST_5 5
; var CONST_9 9
; var CONST_6 6
; var CONST_1A 1a
; var CONST_17 17
; var CONST_2 2
; var CONST_-8 -8
; var CONST_10 10
; var CONST_8 8

0000000000000000 ; raw 0000000000000000 # tmp
0000000000000000 ; raw 0000000000000000 # val
0000000000000000 ; raw 0000000000000000 # c
0000000000000000 ; raw 0000000000000000 # cur
fffffffffffffff1 ; raw fffffffffffffff1 # i
00000000000000b0 ; raw 00000000000000b0 # loaderLen
ffffffffffffffff ; raw ffffffffffffffff # CONST_-1
0000000000000022 ; raw 0000000000000022 # CONST_22
0000000000000001 ; raw 0000000000000001 # CONST_1
000000000000000c ; raw 000000000000000c # CONST_C
000000000000000a ; raw 000000000000000a # CONST_A
0000000000000005 ; raw 0000000000000005 # CONST_5
0000000000000009 ; raw 0000000000000009 # CONST_9
0000000000000006 ; raw 0000000000000006 # CONST_6
000000000000001a ; raw 000000000000001a # CONST_1A
0000000000000017 ; raw 0000000000000017 # CONST_17
0000000000000002 ; raw 0000000000000002 # CONST_2
fffffffffffffff8 ; raw fffffffffffffff8 # CONST_-8
0000000000000010 ; raw 0000000000000010 # CONST_10
0000000000000008 ; raw 0000000000000008 # CONST_8
~
