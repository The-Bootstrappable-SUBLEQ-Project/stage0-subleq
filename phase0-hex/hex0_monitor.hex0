# Copyright (C) 2022 NyanCatTW1
# This file is part of stage0-subleq.

# stage0-subleq is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# stage0-subleq is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with stage0-subleq. If not, see <http://www.gnu.org/licenses/>.

# Standard program start
; addr ZERO 0
; var tmp 0
; addr SERIAL_IN 13ED27E8
0000000000000000 0000000000000000 0000000000000018 ; lblsq ZERO ZERO EP

; label EP
# MAIN is the main routine for handling inputs
; label MAIN
# val is intentionally kept negative to make it easier to add to cur
; var val 0
; var c 0

# Start getchar c tmp

# Start set tmp 1
0000000000000710 0000000000000710 0000000000000030 ; relsq tmp tmp 1
0000000000000710 0000000000000740 0000000000000048 ; relsq tmp CONST_-1 1
# End set

0000000000000710 0000000013ed27e8 0000000000000078 ; relsq tmp SERIAL_IN 2
# reljmp -1
0000000000000000 0000000000000000 0000000000000048 ; relsq ZERO ZERO -1
# zero SERIAL_IN
0000000013ed27e8 0000000013ed27e8 0000000000000090 ; relsq SERIAL_IN SERIAL_IN 1
# movneg c tmp
0000000000000720 0000000000000720 00000000000000a8 ; relsq c c 1
0000000000000720 0000000000000710 00000000000000c0 ; relsq c tmp 1
# End getchar


# Handle NUL ~ "
0000000000000720 0000000000000748 0000000000000018 ; lblsq c CONST_22 MAIN

# Handle #
0000000000000720 0000000000000750 00000000000002b8 ; lblsq c CONST_1 COMMENT

# Handle $ ~ /
0000000000000720 0000000000000758 0000000000000018 ; lblsq c CONST_C MAIN

# Handle 0 ~ 9
# movneg val c
0000000000000718 0000000000000718 0000000000000120 ; relsq val val 1
0000000000000718 0000000000000720 0000000000000138 ; relsq val c 1
0000000000000718 0000000000000740 0000000000000150 ; relsq val CONST_-1 1
0000000000000720 0000000000000760 00000000000003d8 ; lblsq c CONST_A WRITE

# Handle :
0000000000000720 0000000000000750 0000000000000018 ; lblsq c CONST_1 MAIN

# Handle ;
0000000000000720 0000000000000750 00000000000002b8 ; lblsq c CONST_1 COMMENT

# Handle < ~ @
0000000000000720 0000000000000768 0000000000000018 ; lblsq c CONST_5 MAIN

# Handle A ~ F
# movneg val c
0000000000000718 0000000000000718 00000000000001c8 ; relsq val val 1
0000000000000718 0000000000000720 00000000000001e0 ; relsq val c 1
0000000000000718 0000000000000770 00000000000001f8 ; relsq val CONST_9 1
0000000000000720 0000000000000778 00000000000003d8 ; lblsq c CONST_6 WRITE

# Handle G ~ `
0000000000000720 0000000000000780 0000000000000018 ; lblsq c CONST_1A MAIN

# Handle a ~ f
# movneg val c
0000000000000718 0000000000000718 0000000000000240 ; relsq val val 1
0000000000000718 0000000000000720 0000000000000258 ; relsq val c 1
0000000000000718 0000000000000770 0000000000000270 ; relsq val CONST_9 1
0000000000000720 0000000000000778 00000000000003d8 ; lblsq c CONST_6 WRITE

# Handle g ~ ~
0000000000000720 0000000000000788 0000000000000018 ; lblsq c CONST_24 MAIN

# Handle DEL (0x7f)
0000000000000000 0000000000000000 00000000000005b8 ; lblsq ZERO ZERO COPY


# COMMENT ignores characters until \r or \n is fed
; label COMMENT

# Start getchar c tmp

# Start set tmp 1
0000000000000710 0000000000000710 00000000000002d0 ; relsq tmp tmp 1
0000000000000710 0000000000000740 00000000000002e8 ; relsq tmp CONST_-1 1
# End set

0000000000000710 0000000013ed27e8 0000000000000318 ; relsq tmp SERIAL_IN 2
# reljmp -1
0000000000000000 0000000000000000 00000000000002e8 ; relsq ZERO ZERO -1
# zero SERIAL_IN
0000000013ed27e8 0000000013ed27e8 0000000000000330 ; relsq SERIAL_IN SERIAL_IN 1
# movneg c tmp
0000000000000720 0000000000000720 0000000000000348 ; relsq c c 1
0000000000000720 0000000000000710 0000000000000360 ; relsq c tmp 1
# End getchar

0000000000000720 0000000000000770 00000000000002b8 ; lblsq c CONST_9 COMMENT
# Handle LF
0000000000000720 0000000000000750 0000000000000018 ; lblsq c CONST_1 MAIN
0000000000000720 0000000000000790 00000000000002b8 ; lblsq c CONST_2 COMMENT
# Handle CR
0000000000000720 0000000000000750 0000000000000018 ; lblsq c CONST_1 MAIN
0000000000000000 0000000000000000 00000000000002b8 ; lblsq ZERO ZERO COMMENT


# WRITE adds the hex character to cur, and copies cur to the buffer + increases its address by 8 every 16 characters
; label WRITE
; var cur 0
# The following multiplies cur by 16
# tmp = -5 * cur
# movneg tmp cur
0000000000000710 0000000000000710 00000000000003f0 ; relsq tmp tmp 1
0000000000000710 0000000000000728 0000000000000408 ; relsq tmp cur 1
0000000000000710 0000000000000728 0000000000000420 ; relsq tmp cur 1
0000000000000710 0000000000000728 0000000000000438 ; relsq tmp cur 1
0000000000000710 0000000000000728 0000000000000450 ; relsq tmp cur 1
0000000000000710 0000000000000728 0000000000000468 ; relsq tmp cur 1

# cur -= 3 * tmp = -15 * cur
0000000000000728 0000000000000710 0000000000000480 ; relsq cur tmp 1
0000000000000728 0000000000000710 0000000000000498 ; relsq cur tmp 1
0000000000000728 0000000000000710 00000000000004b0 ; relsq cur tmp 1

0000000000000728 0000000000000718 00000000000004c8 ; relsq cur val 1

# i will turn positive every 16 iterations
; var i -f
0000000000000730 0000000000000740 0000000000000018 ; lblsq i CONST_-1 MAIN

# Copy to the buffer and increase its address
; addr dstEnd 0
; addr bufEnd 100000
# The buffer is also intentionally kept negative to ease copying
# movneg bufEnd cur
0000000000100000 0000000000100000 00000000000004f8 ; relsq bufEnd bufEnd 1
0000000000100000 0000000000000728 0000000000000510 ; relsq bufEnd cur 1
0000000000000728 0000000000000728 0000000000000528 ; relsq cur cur 1
00000000000006c0 0000000000000798 0000000000000540 ; relsq dstEnd_addrRef_0 CONST_-8 1
00000000000004e0 0000000000000798 0000000000000558 ; relsq bufEnd_addrRef_0 CONST_-8 1
00000000000004e8 0000000000000798 0000000000000570 ; relsq bufEnd_addrRef_1 CONST_-8 1
00000000000004f8 0000000000000798 0000000000000588 ; relsq bufEnd_addrRef_2 CONST_-8 1
00000000000006c8 0000000000000798 00000000000005a0 ; relsq bufEnd_addrRef_3 CONST_-8 1
0000000000000730 00000000000007a0 0000000000000018 ; lblsq i CONST_15 MAIN


# COPY copies the loader to a lower memory (To avoid overwriting) and jumps to the loader
# loaderOrg is currently hardcoded due to limitations of the lsq_to_sq tool
; label COPY
; addr loaderOrg 6c0
; addr loaderDst 200000
; var loaderLen 68

# Start mov loaderDst loaderOrg tmp
# movneg tmp loaderOrg
0000000000000710 0000000000000710 00000000000005d0 ; relsq tmp tmp 1
0000000000000710 00000000000006c0 00000000000005e8 ; relsq tmp loaderOrg 1
# movneg loaderDst tmp
0000000000200000 0000000000200000 0000000000000600 ; relsq loaderDst loaderDst 1
0000000000200000 0000000000000710 0000000000000618 ; relsq loaderDst tmp 1
# End mov

00000000000005d8 0000000000000798 0000000000000630 ; relsq loaderOrg_addrRef_0 CONST_-8 1
00000000000005e8 0000000000000798 0000000000000648 ; relsq loaderDst_addrRef_0 CONST_-8 1
00000000000005f0 0000000000000798 0000000000000660 ; relsq loaderDst_addrRef_1 CONST_-8 1
0000000000000600 0000000000000798 0000000000000678 ; relsq loaderDst_addrRef_2 CONST_-8 1
00000000000006a0 0000000000000798 0000000000000690 ; relsq loaderDst_addrRef_3 CONST_-8 1
# Jump to loaderDst once loaderLen is <= 0
0000000000000738 00000000000007a8 0000000000200000 ; lblsq loaderLen CONST_8 loaderDst
0000000000000000 0000000000000000 00000000000005b8 ; lblsq ZERO ZERO COPY


# LOADER copies the buffer to the highest memory (0~...) and jumps to 0
# No external variables are used within LOADER, as those would be overridden by the new program
# The addresses are also hardcoded based on loaderDst
; label LOADER
0000000000000000 0000000000100000 00000000000006d8 ; relsq dstEnd bufEnd 1
# Decrease bufEnd by 8
0000000000200008 0000000000200048 0000000000200030 ; raw 0000000000200008 0000000000200048 0000000000200030
# Decrease dstEnd by 8, and jump to 0 if dstEnd <= 0
0000000000200000 0000000000200048 0000000000000000 ; raw 0000000000200000 0000000000200048 0000000000000000
# CONST_8
0000000000000008 ; raw 0000000000000008

; var CONST_-1 -1
; var CONST_22 22
; var CONST_1 1
; var CONST_C c
; var CONST_A a
; var CONST_5 5
; var CONST_9 9
; var CONST_6 6
; var CONST_1A 1a
; var CONST_24 24
; var CONST_2 2
; var CONST_-8 -8
; var CONST_15 15
; var CONST_8 8

0000000000000000 ; raw 0000000000000000 # tmp
0000000000000000 ; raw 0000000000000000 # val
0000000000000000 ; raw 0000000000000000 # c
0000000000000000 ; raw 0000000000000000 # cur
fffffffffffffff1 ; raw fffffffffffffff1 # i
0000000000000068 ; raw 0000000000000068 # loaderLen
ffffffffffffffff ; raw ffffffffffffffff # CONST_-1
0000000000000022 ; raw 0000000000000022 # CONST_22
0000000000000001 ; raw 0000000000000001 # CONST_1
000000000000000c ; raw 000000000000000c # CONST_C
000000000000000a ; raw 000000000000000a # CONST_A
0000000000000005 ; raw 0000000000000005 # CONST_5
0000000000000009 ; raw 0000000000000009 # CONST_9
0000000000000006 ; raw 0000000000000006 # CONST_6
000000000000001a ; raw 000000000000001a # CONST_1A
0000000000000024 ; raw 0000000000000024 # CONST_24
0000000000000002 ; raw 0000000000000002 # CONST_2
fffffffffffffff8 ; raw fffffffffffffff8 # CONST_-8
0000000000000015 ; raw 0000000000000015 # CONST_15
0000000000000008 ; raw 0000000000000008 # CONST_8
